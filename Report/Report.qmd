---
title: "Report"
author: "Group 14"
format: pdf
editor: visual
---

# Report

## Part 1: Database Design and Implementation

### 1.1 E-R Diagram Design

![Initial E-R Diagram](images/First%20Diagram.jpg){fig-align="center" width="410"}

![Final E-R Diagram](images/Final%20Diagram.jpg){fig-align="center" width="506"}

At the initial creation, our group developed first Entity-Relationship (E-R) diagram with nine entities including Supplier, Product, Ads, Category, Inventory, Customer, Order, Payment, and Shipping -- connected by eleven relationships. (refer to Figure 1) Each entity contains a primary key for unique identification of each instance in the entities, related attributes, and a foreign key as needed. However, through the deeper examination when converting the diagram into the schema, it was found that there were several errors in the initial E-R diagram, making the database incompatible with the third normal form (3NF). The following adjustments - such as adding and removing entities, relationships, and attributes - were done to solved the problem.

Firstly, we decided that Order, Category, and Ads should be remove. The Order entity was more appropriate to be a relationship between the Customer entity and Product entity to prevent redundant functionality and simplify the diagram. The Category entity was eliminated and changed to an attribute under the Product entity to made the synthetic data we generated be more realistic and reasonable. Ads were removed due to the complexity of generating and maintaining such data. (CAN ADD MORE REASON)

Secondly, we detected some looping relationships which created redundancy in the data storage of the database. For example, there is a relationship between Supplier that supplies Product, a relationship between Supplier that supplies Inventory, and a relationship of Inventory that has Product. By eliminating the relationship between Supplier and Inventory and utilising the PRODUCT_ID as a linkage, redundancy was decreased. Similar relationship issues also occurred around Customers, Payment, and Shipping. We decided to modify those relationships resulting in a reduction from eleven to five total relationships.

Lastly, we made changes in some certain attributes. We had spotted three non-atomic attributes including SHIPMENT_ADDRESS, BILLING_ADDRESS, and DESCRIPTION. For the address, more attributes for city, country, and zip code were added. The DESCRIPTION attribute was deleted since we already had PRODUCT_CATEGORY attribute which has a similar function of describing the product. Moreover, we removed the PRODUCT_ID from the Supplier entity as the SUPPLIER_ID attribute was already existed in the Product entity. This enables us to use Supplier as a starting point of the schema creation since it is the entity without the foreign key. Furthermore, an INVENTORY_ID was created to solve the lack of a primary key in Inventory entity.

After all of these adjustments, a final E-R diagram that could accommodate a database in 3NF was produced. In order to maintain data integrity and reduce redundancy, the resultant diagram consists of six entities: Supplier, Product, Inventory, Customer, Payment, and Shipping. These entities are related by five relationships. (refer to Figure 2)

![Figure 3: Relationship Set](images/Logical.jpg){fig-align="center" width="388"}

![Figure 4: Relational Schema](images/Relational%20Schema.png){fig-align="center" width="366"}

The assumptions used for the relationships between entities of the final E-R diagram

1.  A single product may be provided by several providers

2.  The same product can possibly be stored across multiple shelves depending on the product quantity.

3.  Each customer can order multiple products, and each product can be bought by several customers

4.  A single customer can make many payments, but each payment could be paid by only one customer

5.  One payment can be associated with only one shipment

All the relationships between entities were illustrated in Figure 3 and Figure 4

### 1.2 SQL Database Schema Creation

The initial schema was created based on the initial E-R Diagram containing nine tables according to the first nine entities our group identified. However, the subsequent investigation revealed that the database lacked normalization in form of 3NF. This resulted in redundancies and dependency issues as described in the E-R Diagram Design phase.

In order to rectify this, we took care of unnecessary entities, redundant relationships, and non-atomic attributes. After this process, the final database schema consisting of six tables - Supplier, Product, Inventory, Customer, Payment, and Shipping -- according to the final E-R diagram was created. With utilisation of SQL code, all attributes were added as the columns of the tables. The primary key and foreign key of each entity were also determined. Additionally, we also carefully specified the data type of each attribute or each column of the table- for example, SUPPLIER_NAME should be text, PRICE should be numeric, and CUSTOMER_BIRTHDAY should be date. This is important as it helps in organizing and managing the data while maintaining consistency and integrity.

The assumptions used for the final database schema

The SQL codes for schema creation are as follows

```{r}
# Establish a connection to the database
db <- dbConnect(RSQLite::SQLite(), dbname = "e_commerce_database.db")

# Function to check if a table exists in the database
table_exists <- function(db, table_name) {
  exists <- dbGetQuery(db, paste0("SELECT name FROM sqlite_master WHERE type='table' AND name='", table_name, "';"))
  nrow(exists) > 0
}

# Function to create a table if it does not exist
create_table_if_not_exists <- function(db, table_name, create_table_sql) {
  if (!table_exists(db, table_name)) {
    dbExecute(db, create_table_sql)
  }
}

# SQL statements to create tables
create_supplier_table_sql <- "CREATE TABLE Supplier (
  SUPPLIER_ID TEXT PRIMARY KEY,
  SUPPLIER_NAME TEXT,
  SUPPLIER_PHONE TEXT,
  SUPPLIER_EMAIL TEXT
)"

create_product_table_sql <- "CREATE TABLE Product (
  PRODUCT_ID TEXT PRIMARY KEY,
  PRODUCT_NAME TEXT,
  PRODUCT_CATEGORY TEXT,
  PRICE NUMERIC,
  SUPPLIER_ID TEXT,
  FOREIGN KEY(SUPPLIER_ID) REFERENCES Supplier(SUPPLIER_ID)
)"

create_inventory_table_sql <- "CREATE TABLE Inventory (
  INVENTORY_ID TEXT PRIMARY KEY,
  STOCK INTEGER,
  SHELF_NO TEXT,
  PRODUCT_ID TEXT,
  FOREIGN KEY(PRODUCT_ID) REFERENCES Product(PRODUCT_ID)
)"

create_customer_table_sql <- "CREATE TABLE Customer (
  CUSTOMER_ID TEXT PRIMARY KEY,
  CUSTOMER_FIRSTNAME TEXT,
  CUSTOMER_LASTNAME TEXT,
  CUSTOMER_EMAIL TEXT,
  CUSTOMER_PHONE TEXT,
  CUSTOMER_BIRTHDAY DATE,
  CUSTOMER_GENDER TEXT,
  SHIPMENT_ID TEXT,
  PAYMENT_ID TEXT
)"

create_shipping_table_sql <- "CREATE TABLE Shipping (
  SHIPMENT_ID TEXT PRIMARY KEY,
  SHIPMENT_DATE DATE,
  SHIPMENT_ADDRESS TEXT,
  SHIPMENT_CITY TEXT,
  SHIPMENT_ZIPCODE TEXT,
  SHIPMENT_COUNTRY TEXT,
  CUSTOMER_ID TEXT,
  PRODUCT_ID TEXT,
  FOREIGN KEY(CUSTOMER_ID) REFERENCES Customer(CUSTOMER_ID),
  FOREIGN KEY(PRODUCT_ID) REFERENCES Product(PRODUCT_ID)
)"

create_payment_table_sql <- "CREATE TABLE Payment (
  PAYMENT_ID TEXT PRIMARY KEY,
  PAYMENT_METHOD TEXT,
  ORDER_AMOUNT NUMERIC,
  PAYMENT_DATE DATE,
  BILLING_ADDRESS TEXT,
  BILLING_CITY TEXT,
  BILLING_ZIPCODE TEXT,
  BILLING_COUNTRY TEXT,
  CUSTOMER_ID TEXT,
  PRODUCT_ID TEXT,
  FOREIGN KEY(CUSTOMER_ID) REFERENCES Customer(CUSTOMER_ID),
  FOREIGN KEY(PRODUCT_ID) REFERENCES Product(PRODUCT_ID)
)"

# Create tables if they do not exist
create_table_if_not_exists(db, 'Supplier', create_supplier_table_sql)
create_table_if_not_exists(db, 'Product', create_product_table_sql)
create_table_if_not_exists(db, 'Inventory', create_inventory_table_sql)
create_table_if_not_exists(db, 'Customer', create_customer_table_sql)
create_table_if_not_exists(db, 'Shipping', create_shipping_table_sql)
create_table_if_not_exists(db, 'Payment', create_payment_table_sql)

```
